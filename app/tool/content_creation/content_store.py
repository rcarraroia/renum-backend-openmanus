"""
Content Store Tool for OpenManus.

This tool provides functionality for storing and retrieving generated content,
allowing persistence of content across sessions.
"""

import json
import logging
import os
from typing import Dict, Any, List, Optional, Union

from app.tool.base import BaseTool

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ContentStoreTool(BaseTool):
    """
    Tool for storing and retrieving generated content.
    
    This tool provides a simple persistence layer for content generated by
    other tools, allowing content to be saved, retrieved, and managed across
    sessions.
    """
    
    name = "content_store"
    description = "Store and retrieve generated content"
    
    def __init__(self, storage_path: Optional[str] = None):
        """
        Initialize the ContentStoreTool.
        
        Args:
            storage_path: Path to the JSON file for content storage
        """
        super().__init__()
        
        # Set default storage path if not provided
        if storage_path is None:
            storage_path = os.path.join(os.getcwd(), "content_store.json")
        
        self.storage_path = storage_path
        self._ensure_storage_exists()
        
        logger.info(f"ContentStoreTool initialized with storage at: {storage_path}")
    
    def _ensure_storage_exists(self) -> None:
        """Ensure the storage file exists, creating it if necessary."""
        if not os.path.exists(self.storage_path):
            # Create the initial storage structure
            initial_data = {
                "emails": [],
                "social_media_posts": [],
                "other_content": []
            }
            
            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(self.storage_path), exist_ok=True)
            
            # Write the initial data
            with open(self.storage_path, "w", encoding="utf-8") as f:
                json.dump(initial_data, f, indent=2)
            
            logger.info(f"Created new content store at: {self.storage_path}")
    
    def _load_storage(self) -> Dict[str, List[Dict[str, Any]]]:
        """
        Load the content storage from disk.
        
        Returns:
            The loaded storage data
        """
        try:
            with open(self.storage_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except (json.JSONDecodeError, FileNotFoundError) as e:
            logger.error(f"Error loading content store: {e}")
            # Return empty storage structure
            return {
                "emails": [],
                "social_media_posts": [],
                "other_content": []
            }
    
    def _save_storage(self, data: Dict[str, List[Dict[str, Any]]]) -> bool:
        """
        Save the content storage to disk.
        
        Args:
            data: The storage data to save
            
        Returns:
            True if save was successful, False otherwise
        """
        try:
            with open(self.storage_path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2)
            return True
        except Exception as e:
            logger.error(f"Error saving content store: {e}")
            return False
    
    async def _arun(
        self,
        action: str,
        content_type: str,
        content_data: Optional[Dict[str, Any]] = None,
        content_id: Optional[str] = None,
        **kwargs
    ) -> Dict[str, Any]:
        """
        Perform operations on the content store.
        
        Args:
            action: The action to perform (save, get, list, delete)
            content_type: The type of content (email, social_media_post, other)
            content_data: The content data to save (for save action)
            content_id: The ID of the content to retrieve/delete (for get/delete actions)
            
        Returns:
            Dictionary containing the result of the operation
        """
        logger.info(f"Performing {action} operation on {content_type} content")
        
        # Validate inputs
        if not action:
            return {"error": "Action is required"}
        
        if not content_type:
            return {"error": "Content type is required"}
        
        # Normalize content type
        content_type_map = {
            "email": "emails",
            "social_media_post": "social_media_posts",
            "other": "other_content"
        }
        
        storage_key = content_type_map.get(content_type.lower())
        if not storage_key:
            return {"error": f"Invalid content type. Choose from: {', '.join(content_type_map.keys())}"}
        
        # Load current storage
        storage = self._load_storage()
        
        # Perform the requested action
        if action.lower() == "save":
            return await self._save_content(storage, storage_key, content_data)
        elif action.lower() == "get":
            return await self._get_content(storage, storage_key, content_id)
        elif action.lower() == "list":
            return await self._list_content(storage, storage_key)
        elif action.lower() == "delete":
            return await self._delete_content(storage, storage_key, content_id)
        else:
            return {"error": f"Invalid action. Choose from: save, get, list, delete"}
    
    async def _save_content(
        self,
        storage: Dict[str, List[Dict[str, Any]]],
        storage_key: str,
        content_data: Optional[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        Save content to the store.
        
        Args:
            storage: The loaded storage data
            storage_key: The key for the content type in storage
            content_data: The content data to save
            
        Returns:
            Dictionary containing the result of the operation
        """
        if not content_data:
            return {"error": "Content data is required for save action"}
        
        # Generate a unique ID if not provided
        if "id" not in content_data:
            import uuid
            content_data["id"] = str(uuid.uuid4())
        
        # Add timestamp if not provided
        if "timestamp" not in content_data:
            import datetime
            content_data["timestamp"] = datetime.datetime.now().isoformat()
        
        # Add the content to storage
        storage[storage_key].append(content_data)
        
        # Save the updated storage
        if self._save_storage(storage):
            return {
                "success": True,
                "message": f"Content saved successfully with ID: {content_data['id']}",
                "content_id": content_data["id"]
            }
        else:
            return {"error": "Failed to save content to storage"}
    
    async def _get_content(
        self,
        storage: Dict[str, List[Dict[str, Any]]],
        storage_key: str,
        content_id: Optional[str]
    ) -> Dict[str, Any]:
        """
        Get content from the store.
        
        Args:
            storage: The loaded storage data
            storage_key: The key for the content type in storage
            content_id: The ID of the content to retrieve
            
        Returns:
            Dictionary containing the result of the operation
        """
        if not content_id:
            return {"error": "Content ID is required for get action"}
        
        # Find the content with the specified ID
        for item in storage[storage_key]:
            if item.get("id") == content_id:
                return {
                    "success": True,
                    "content": item
                }
        
        return {"error": f"Content with ID {content_id} not found"}
    
    async def _list_content(
        self,
        storage: Dict[str, List[Dict[str, Any]]],
        storage_key: str
    ) -> Dict[str, Any]:
        """
        List content in the store.
        
        Args:
            storage: The loaded storage data
            storage_key: The key for the content type in storage
            
        Returns:
            Dictionary containing the result of the operation
        """
        # Return the list of content items
        return {
            "success": True,
            "count": len(storage[storage_key]),
            "items": storage[storage_key]
        }
    
    async def _delete_content(
        self,
        storage: Dict[str, List[Dict[str, Any]]],
        storage_key: str,
        content_id: Optional[str]
    ) -> Dict[str, Any]:
        """
        Delete content from the store.
        
        Args:
            storage: The loaded storage data
            storage_key: The key for the content type in storage
            content_id: The ID of the content to delete
            
        Returns:
            Dictionary containing the result of the operation
        """
        if not content_id:
            return {"error": "Content ID is required for delete action"}
        
        # Find and remove the content with the specified ID
        original_count = len(storage[storage_key])
        storage[storage_key] = [item for item in storage[storage_key] if item.get("id") != content_id]
        
        # Check if any item was removed
        if len(storage[storage_key]) == original_count:
            return {"error": f"Content with ID {content_id} not found"}
        
        # Save the updated storage
        if self._save_storage(storage):
            return {
                "success": True,
                "message": f"Content with ID {content_id} deleted successfully"
            }
        else:
            return {"error": "Failed to save changes to storage"}
